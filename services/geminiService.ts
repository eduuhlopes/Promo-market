import { GoogleGenAI, Type } from "@google/genai";
import { Product, ProductPrice } from '../types';

// In a real-world application, the API key should be stored securely and not hardcoded.
// For this environment, we are using the provided key directly to ensure functionality.
const apiKey = "AIzaSyBnMXKvxMnQ7vByvyjhAwuLgT4Rjj2Y4NM";
if (!apiKey) {
  throw new Error("API key is not configured. Please ensure it is set correctly.");
}
const ai = new GoogleGenAI({ apiKey: apiKey });

const cleanJson = (text: string): string => {
  let jsonText = text.trim();
  if (jsonText.startsWith('```json')) {
    jsonText = jsonText.substring(7, jsonText.length - 3).trim();
  } else if (jsonText.startsWith('```')) {
    jsonText = jsonText.substring(3, jsonText.length - 3).trim();
  }
  return jsonText;
};

/**
 * Generates a unique image for a product using the Imagen model.
 */
const generateProductImage = async (productName: string, category: string): Promise<string> => {
    const prompt = `
    Professional, high-quality photo of "${productName}", a ${category} product.
    The product should be clearly visible and centered.
    Background should be clean, simple, and neutral, like a modern kitchen counter or a supermarket shelf.
    Photorealistic style, commercial photography. No text or logos on the image.
  `;

  try {
    const response = await ai.models.generateImages({
        model: 'imagen-4.0-generate-001',
        prompt: prompt,
        config: {
          numberOfImages: 1,
          outputMimeType: 'image/jpeg',
          aspectRatio: '1:1',
        },
    });

    if (response.generatedImages && response.generatedImages.length > 0) {
        const base64ImageBytes = response.generatedImages[0].image.imageBytes;
        return `data:image/jpeg;base64,${base64ImageBytes}`;
    } else {
        throw new Error("No image was generated by the API.");
    }
  } catch (error) {
    console.error(`Error generating image for "${productName}":`, error);
    // Return a fallback or re-throw to be handled by the caller
    throw new Error(`Could not generate image for ${productName}.`);
  }
};

/**
 * Step 1: Fetches a list of product suggestions quickly.
 * This call is optimized for speed by NOT using Google Search and only asking for basic product info.
 */
const fetchProductsFromGemini = async (query: string): Promise<Product[]> => {
  const prompt = `
    Act as a product suggestion API. Based on the user's search query for "${query}", generate a realistic list of 5 to 7 specific product names that could be found in Brazilian supermarkets.
    For each product, provide:
    - A unique ID (e.g., a short hash).
    - The product name (e.g., "Leite Integral Piracanjuba 1L").
    - A relevant category in Portuguese (e.g., 'Laticínios', 'Padaria', 'Hortifruti').
    
    The response should be a JSON array of objects. Do not include prices or supermarket data. This should be a very fast response.
  `;

  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
       config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              id: { type: Type.STRING, description: "A unique identifier for the product." },
              name: { type: Type.STRING, description: "The full name of the product." },
              category: { type: Type.STRING, description: "The product category in Portuguese." },
            },
            required: ['id', 'name', 'category'],
          }
        }
      },
    });

    const jsonText = cleanJson(response.text);
    if (!jsonText) {
        throw new Error("A API retornou uma resposta vazia.");
    }
    
    const products: Product[] = JSON.parse(jsonText).map((p: any) => ({
        ...p,
        imageUrl: ``, // Will be generated on-demand
        prices: [] // Prices will be fetched on demand
    }));
    
    return products;
  } catch (error) {
    console.error("Error fetching initial products from Gemini API:", error);
    throw new Error("Não foi possível buscar os produtos. Verifique sua conexão ou tente novamente mais tarde.");
  }
};

/**
 * Step 2: Fetches detailed pricing information for a SINGLE product on demand.
 * This function uses a robust two-step process for maximum accuracy:
 * 1. An initial call uses Google Search to perform targeted research for live, verifiable data.
 * 2. A second call parses that researched text into guaranteed, clean JSON.
 */
const fetchProductPricesFromGemini = async (productName: string, latitude: number, longitude: number): Promise<ProductPrice[]> => {
    // Step 1: Use Google Search to get grounded, up-to-date information as text. This prompt is highly specific to ensure accuracy.
    const searchPrompt = `
    Act as an expert price comparison researcher for Brazilian supermarkets. Your task is to find the most accurate, up-to-date, and verifiable information for the product: "${productName}". The user's location (lat: ${latitude}, lon: ${longitude}) can help prioritize local availability on national e-commerce sites.

    Using Google Search, perform targeted searches on the OFFICIAL WEBSITES of major Brazilian e-commerce and supermarket retailers (e.g., Carrefour, Pão de Açúcar, Extra, Magazine Luiza, Americanas).

    For each retailer where you find the product, provide a summary containing ONLY the following information:
    - Supermarket Name: The name of the retailer.
    - Exact Price: The current, live price in BRL, as a number (e.g., 24.99).
    - Direct Product URL: The full, direct, and valid URL to the product's own page. This MUST NOT be a search result page, a category page, or the homepage.
    - Promotion Details: Any specific promotion, like "50% de desconto na segunda unidade". If none, state "N/A".
    - Supermarket Logo URL: A valid, public URL for a high-quality logo of the supermarket.
    - Branch Address: The approximate physical address of a nearby branch, if available online.
    - Opening Hours: The opening hours of that branch, if available online.

    Present the results as a clear, plain-text list. Each retailer's entry should be distinct.
  `;

  try {
    const searchResponse = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: searchPrompt,
      config: {
        tools: [{ googleSearch: {} }],
      },
    });

    const groundedText = searchResponse.text;
    if (!groundedText || groundedText.trim().length === 0) {
      console.log(`No search results found for "${productName}".`);
      return []; // No information found, which is a valid result.
    }

    // Step 2: Use a second, structured call to parse the researched text into clean JSON.
    const extractionPrompt = `
      Based *only* on the provided text context below, extract the supermarket price details into a JSON array.
      Adhere strictly to the provided JSON schema. Do not invent, hallucinate, or infer any information not present in the text.
      If the text contains no valid price information for a supermarket, return an empty array.

      Context:
      ---
      ${groundedText}
      ---
    `;

    const extractionResponse = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: extractionPrompt,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              supermarket: { type: Type.STRING },
              price: { type: Type.NUMBER },
              promotion: { type: Type.STRING, nullable: true },
              supermarketLogoUrl: { type: Type.STRING },
              productUrl: { type: Type.STRING },
              address: { type: Type.STRING, nullable: true },
              openingHours: { type: Type.STRING, nullable: true },
            },
            required: ['supermarket', 'price', 'supermarketLogoUrl', 'productUrl']
          }
        }
      },
    });
    
    const jsonText = cleanJson(extractionResponse.text);
    if (!jsonText) {
        return [];
    }
    
    // Final validation to filter out any entries that might have slipped through with invalid URLs
    let prices: ProductPrice[] = JSON.parse(jsonText);
    prices = prices.filter(p => p.productUrl && p.productUrl.startsWith('http'));

    return prices;

  } catch (error) {
    console.error(`Error fetching prices for "${productName}" from Gemini API:`, error);
    // Let the caller handle the error, so it can display a message in the specific card.
    throw new Error(`Não foi possível buscar os preços para ${productName}.`);
  }
}


export { fetchProductsFromGemini, fetchProductPricesFromGemini, generateProductImage };